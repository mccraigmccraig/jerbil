require 'rake'
require 'rake/tasklib'
require 'jerbil/java_helper'
require 'yaml'
require 'set'

module Jerbil 
  module Hibernate 
    # Generates a SQL schema from EJB3/Hibernate-annotated classes like Hibernate's
    # SchemaExport tool. Typically Jerbil::AptTask is used to compile source files and
    # gather a list of entities which then gets serialized to a YAML file.
    # ExportSchemaTask then reads this file and uses Hibernate's schema exporting 
    # features to generate SQL
    #
    # == Example
    #   Jerbil::Hibernate::ExportSchemaTask.new(:export_schema) do |t|
    #       t.schemafile = "schema.sql"
    #       t.entities_yml = ENTITIES_YML      
    #   end
    class ExportSchemaTask < Rake::TaskLib
      include JavaHelper
      
      attr_accessor :name
      
      # SQL schema destination file (default: schema.sql)
      attr_accessor :schemafile
			
      # A file containing a list of entities (<em>javax.persistence.Entity</em>),
      # serialized as a list of strings (YAML format).
      attr_accessor :entities_yml

      # a file containing a map of properties, property names are keys in the map, and
      # property values are values in the map
      attr_accessor :properties_yml
			
      # Classname implementing the db dialect, defaults to
      # <em>org.hibernate.dialect.MySQL5Dialect</em>
      attr_accessor :dialect
			
      # SQL statements to be executed before generated sql.
      attr_accessor :preamble
      attr_accessor :epilogue
			
      # FQN of a package containing package-info.java to be used by
      # hibernate.
      attr_accessor :package
      
      # Pretty printing of generated SQL (default: true)
      attr_accessor :prettyprint
      
      def initialize(name=:export_schema)
        @name = name
        @dependencies = []
        @classfilter = nil
        @prettyprint = true
        @schemafile = "schema.sql"
        @entities_yml = "entities.yml"
        @properties_yml = nil
        @dialect = "org.hibernate.dialect.MySQL5Dialect"
                
        yield self if block_given?
        define
      end
      
      def define # :nodoc:
        task name => dependencies do |t|       
    
          entities = File.open(entities_yml) {|f| YAML.load(f)}
    
          raise 'no annotated entities found!' if entities.empty?
          
          #puts "found #{entities.size} entities"    
          entities = entities.dup.select { |e| @classfilter.call(e) } if @classfilter         
          entity_classes = entities.map {|klass| Rjb::import(klass)}

          properties = (YAML.load_file(@properties_yml) if @properties_yml) || {}

          cfg = get_config(entity_classes, properties, package)
          sql = cfg.generateSchemaCreationScript(Rjb::import(dialect).new)
          
          schema =  "# -- do not edit ---\n"
          schema << "# generated by Jerbil::Hibernate::ExportSchemaTask at #{Time.new}\n\n"
          
          schema << preamble << "\n" if preamble
          
          sql.each do |s|
            s = format(s) if prettyprint
            schema << "#{s};"
          end
          
          schema << "\n\n#{epilogue}" if epilogue
                             
          File.open(schemafile, "w") {|file| file << schema }
        end
        file schemafile => name
        task name => entities_yml
      end
      
      # Filters all entities. Useful to only export schema for a subset of classes.
      # ====Example
      # Jerbil::Hibernate::ExportSchemaTask.new(:export_schema) do |t|
      #    t.filter { |classname| classname =~ /^foo/ }    
      #  end
      def filter(*args, &block)
          @classfilter = block
      end
        
      protected
      def get_config(classes, properties, package=nil)
        anncfg = Rjb::import('org.hibernate.cfg.AnnotationConfiguration')
        acfg = anncfg.new
        packages = Set.new
        classes.each do |clazz|
          #puts "adding " + clazz.class.to_s
          acfg.addAnnotatedClass(clazz)
          
          pkg = clazz.getPackage
          packages << pkg.getName if pkg && pkg.getAnnotations.length > 0
        end
        packages << package if package
        packages.each { |pkg| acfg.addPackage(pkg) }
                
        properties.each do |key,value|
          acfg.setProperty(key, value)
        end
        
        acfg
      end
      
      def format(sql)
        Rjb::import('org.hibernate.pretty.DDLFormatter').new(sql).format      
      end
    end
  end
end

